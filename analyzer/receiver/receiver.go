// Package Receiver implemnts the Redis event listener for events
// generated by the locator.  In production, this would realistically
// be in a separate server from the locator, but keeping it in the
// same process changes nothing functionally, including thread safety.
// The pubsub cannot be used mre than once in a redis-client instance,
// but we're only using it once here.
package receiver

import (
	"context"
	"fmt"
	"math"
	"os"
	"strconv"
	"strings"
	"sync"
	"sync/atomic"
	"time"

	"github.com/gdotgordon/locator-demo/analyzer/types"
	"github.com/go-redis/redis"
)

type Receiver struct {
	cli        *redis.Client
	latencyCnt uint64
	succCnt    int64
	errCnt     int64
}

// New creates a new event receiver for keyspace events.
func New(cli *redis.Client) (*Receiver, error) {
	return &Receiver{cli: cli}, nil
}

// Run is the main event loop processor.  For each event read, it
// takes the appropriate action, which in our case is to simply store
// them in our instance.  In real life, you might pass the data off
// to a tracking system like Prometheus or a database.
func (r *Receiver) Run(ctx context.Context, numWorkers int) {
	topic := fmt.Sprintf("__keyspace@0__:%s*", types.KeyPrefix)
	sub := r.cli.PSubscribe(topic)
	// Wait for confirmation that subscription is created before publishing anything.
	_, err := sub.Receive()
	if err != nil {
		panic(err)
	}
	eventChan := sub.Channel()

	// This function will be invoked in thr event loop, and is moved
	// out of the loop for readability's sake.
	var wg sync.WaitGroup
	processEvents := func() {
		defer wg.Done()

		for {
			select {
			case <-ctx.Done():
				return
			case msg, ok := <-eventChan:
				if !ok {
					return
				}
				fmt.Printf("Received message: +%v\n", msg)
				if strings.HasSuffix(msg.Channel, ":latency") &&
					msg.Payload == "lpush" {
					atomic.AddUint64(&r.latencyCnt, 1)
				} else if strings.HasSuffix(msg.Channel, ":success") &&
					msg.Payload == "incrby" {
					atomic.AddInt64(&r.succCnt, 1)
				} else if strings.HasSuffix(msg.Channel, ":error") &&
					msg.Payload == "incrby" {
					atomic.AddInt64(&r.errCnt, 1)
				}
				fmt.Printf(" go routine received message: %+v\n", msg)
				fmt.Printf("with %v, %v, payload: '%v'\n", msg.Channel, msg.Pattern, msg.Payload)
				ndx := strings.Index(msg.Channel, ":")
				key := msg.Channel[ndx+1:]
				fmt.Println("key: ", key)
				res, err := r.cli.LRange(types.LatencyKey, 0, 100).Result()
				if err != nil {
					fmt.Fprintf(os.Stderr, "Error getting key: '%s'\n", err)
					break
				}
				fmt.Printf("value is '%s'\n", res)
			}
		}
	}

	// Launch the event loops.
	go func() {
		defer sub.Close()

		for i := 0; i < numWorkers; i++ {
			wg.Add(1)
			go func() {
				processEvents()
			}()
		}
		wg.Wait()
	}()
}

func (r *Receiver) GetStats() (*types.StatsResponse, error) {
	res, err := r.cli.LRange(types.LatencyKey, 0, 100).Result()
	if err != nil {
		return nil, err
	}
	var sum int64
	for _, v := range res {
		f, err := strconv.ParseInt(v, 10, 64)
		if err != nil {
			return nil, err
		}
		sum += f
	}
	var avg float64
	if len(res) > 0 {
		avg = float64(sum) / float64(len(res))
	}
	davg := time.Duration(int64(math.Round(avg)))
	return &types.StatsResponse{Success: r.succCnt, Failure: r.errCnt,
		Latency: davg.String()}, nil
}
