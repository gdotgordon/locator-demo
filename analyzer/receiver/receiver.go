// Package Receiver implemnts the Redis event listener for events
// generated by the locator.  In production, this would realistically
// be in a separate server from the locator, but keeping it in the
// same process changes nothing functionally, including thread safety.
// The pubsub cannot be used mre than once in a redis-client instance,
// but we're only using it once here.
package receiver

import (
	"context"
	"fmt"
	"os"
	"strconv"
	"strings"
	"sync"
	"sync/atomic"
	"time"

	"github.com/gdotgordon/locator-demo/analyzer/types"
	"github.com/go-redis/redis"
)

type Receiver struct {
	cli        *redis.Client
	latencyCnt uint64
	succCnt    int64
	errCnt     int64
	mu         sync.Mutex
}

func New(cli *redis.Client) (*Receiver, error) {
	return &Receiver{cli: cli}, nil
}

func (r *Receiver) Run(ctx context.Context, numWorkers int) {
	topic := fmt.Sprintf("__keyspace@0__:%s*", types.KeyPrefix)
	sub := r.cli.PSubscribe(topic)
	// Wait for confirmation that subscription is created before publishing anything.
	_, err := sub.Receive()
	if err != nil {
		panic(err)
	}
	eventChan := sub.Channel()

	for i := 0; i < numWorkers; i++ {
		go func() {
			for {
				select {
				case <-ctx.Done():
					break
				case msg, ok := <-eventChan:
					if !ok {
						break
					}
					fmt.Printf("Received message: +%v\n", msg)
					if strings.HasSuffix(msg.Channel, ":latency") &&
						msg.Payload == "lpush" {
						atomic.AddUint64(&r.latencyCnt, 1)
					} else if strings.HasSuffix(msg.Channel, ":success") &&
						msg.Payload == "incrby" {
						atomic.AddInt64(&r.succCnt, 1)
					} else if strings.HasSuffix(msg.Channel, ":error") &&
						msg.Payload == "incrby" {
						atomic.AddInt64(&r.errCnt, 1)
					}
					fmt.Printf(" go routine received message: %+v\n", msg)
					fmt.Printf("with %v, %v, payload: '%v'\n", msg.Channel, msg.Pattern, msg.Payload)
					ndx := strings.Index(msg.Channel, ":")
					key := msg.Channel[ndx+1:]
					fmt.Println("key: ", key)
					res, err := r.cli.LRange(types.LatencyKey, 0, 100).Result()
					if err != nil {
						fmt.Fprintf(os.Stderr, "Error getting key: '%s'\n", err)
						break
					}
					fmt.Printf("value is '%s'\n", res)
				}
			}
		}()
	}
}

func (r *Receiver) GetStats() (*types.StatsResponse, error) {
	res, err := r.cli.LRange(types.LatencyKey, 0, 100).Result()
	if err != nil {
		return nil, err
	}
	var sum int64
	for _, v := range res {
		f, err := strconv.ParseInt(v, 10, 64)
		if err != nil {
			return nil, err
		}
		sum += f
	}
	var avg time.Duration
	if len(res) > 0 {
		avg = time.Duration(sum / int64(len(res)))
	}
	return &types.StatsResponse{Success: r.succCnt, Failure: r.errCnt,
		Latency: avg}, nil
}
